# .lattice/tool_env
# Sourced by Lattice before every bash tool invocation.
# Docs: https://latticeruntime.com/hooks/tools
#
# Keep PATH resolution and step logging deterministic across tool calls.
# This mirrors the proven workflow the team liked in lattice-k8s.

lattice_use_nix_devshell_path() {
	local flake_root=""

	# Resolve the flake root from stable workspace signals before considering current cwd.
	if [[ -n "${LATTICE_PROJECT_PATH:-}" && -f "${LATTICE_PROJECT_PATH}/flake.nix" ]]; then
		flake_root="${LATTICE_PROJECT_PATH}"
	elif [[ -f "flake.nix" ]]; then
		flake_root="$(pwd)"
	else
		local git_root=""
		git_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
		if [[ -n "${git_root}" && -f "${git_root}/flake.nix" ]]; then
			flake_root="${git_root}"
		else
			return 0
		fi
	fi

	if ! command -v nix >/dev/null 2>&1; then
		return 0
	fi

	# Keep cache file workspace-specific to avoid collisions between parallel workspaces.
	local workspace_cache_tag="${LATTICE_WORKSPACE_ID:-${LATTICE_WORKSPACE_NAME:-${flake_root}}}"
	workspace_cache_tag="$(printf '%s' "${workspace_cache_tag}" | tr -cs 'A-Za-z0-9._-' '_')"

	local cache_file="/tmp/lattice-nix-path-${workspace_cache_tag}"
	local cache_state_file="${cache_file}.state"
	local inherited_retry_interval_seconds=300

	local should_refresh=0
	if [[ ! -s "${cache_file}" ]]; then
		should_refresh=1
	elif [[ "${flake_root}/flake.nix" -nt "${cache_file}" ]]; then
		should_refresh=1
	elif [[ -f "${flake_root}/flake.lock" && "${flake_root}/flake.lock" -nt "${cache_file}" ]]; then
		should_refresh=1
	elif [[ ! -f "${cache_state_file}" ]]; then
		should_refresh=1
	elif [[ "$(<"${cache_state_file}")" != "nix" ]]; then
		local cache_mtime=0
		if cache_mtime="$(stat -c %Y "${cache_file}" 2>/dev/null)"; then
			:
		elif cache_mtime="$(stat -f %m "${cache_file}" 2>/dev/null)"; then
			:
		else
			cache_mtime=0
		fi

		local now_epoch
		now_epoch="$(date +%s)"
		if ((now_epoch - cache_mtime >= inherited_retry_interval_seconds)); then
			should_refresh=1
		fi
	fi

	local refresh_log="${cache_file}.refresh.log"
		local nix_refresh_timeout_seconds=8

		if [[ "${should_refresh}" -eq 1 ]]; then
			local tmp_cache_file
			tmp_cache_file="$(mktemp "${cache_file}.tmp.XXXXXX")"

			local timeout_cmd=""
			if command -v timeout >/dev/null 2>&1; then
				timeout_cmd="timeout"
			elif command -v gtimeout >/dev/null 2>&1; then
				timeout_cmd="gtimeout"
			fi

			local refresh_exit_code=0
			if [[ -n "${timeout_cmd}" ]]; then
				"${timeout_cmd}" --signal=TERM "${nix_refresh_timeout_seconds}s" \
					nix --extra-experimental-features 'nix-command flakes' develop "${flake_root}#default" -c bash -c "echo \"\$PATH\"" \
					>"${tmp_cache_file}" 2>"${refresh_log}" || refresh_exit_code=$?
			else
				refresh_exit_code=124
				echo "warning: no timeout command available; skipping nix devshell PATH refresh to keep tool hooks responsive" >&2
			fi

			if [[ "${refresh_exit_code}" -eq 0 ]]; then
				if [[ -s "${tmp_cache_file}" ]]; then
					mv "${tmp_cache_file}" "${cache_file}"
					printf '%s' "nix" >"${cache_state_file}"
				else
					rm -f "${tmp_cache_file}"
					echo "warning: nix develop returned an empty PATH; keeping existing PATH" >&2
				fi
			else
				rm -f "${tmp_cache_file}"
				if [[ "${refresh_exit_code}" -eq 124 ]]; then
					echo "warning: timed out refreshing nix devshell PATH cache after ${nix_refresh_timeout_seconds}s; keeping existing PATH" >&2
				else
					echo "warning: failed to refresh nix devshell PATH cache (${cache_file}); keeping existing PATH" >&2
				fi
				if [[ -s "${refresh_log}" ]]; then
					echo "warning: nix develop stderr logged at ${refresh_log}" >&2
				fi
				if [[ -s "${cache_file}" ]]; then
					if [[ ! -f "${cache_state_file}" ]]; then
						printf '%s' "inherited" >"${cache_state_file}" 2>/dev/null || true
					fi
					if [[ "$(<"${cache_state_file}")" != "nix" ]]; then
						touch "${cache_file}" 2>/dev/null || true
					fi
				fi
			fi
		fi

if [[ ! -s "${cache_file}" && -n "${PATH:-}" ]]; then
		if printf '%s' "${PATH}" >"${cache_file}" 2>/dev/null; then
			printf '%s' "inherited" >"${cache_state_file}" 2>/dev/null || true
			echo "warning: seeded nix PATH cache with inherited PATH (${cache_file})" >&2
		fi
	fi

	if [[ -s "${cache_file}" ]]; then
		local cached_path
		cached_path="$(<"${cache_file}")"
		export PATH="${cached_path}"
		return 0
	fi

	if [[ -s "${refresh_log}" ]]; then
		echo "warning: nix devshell PATH cache unavailable; continuing with inherited PATH (details: ${refresh_log})" >&2
	fi

	return 0
}

if ! lattice_use_nix_devshell_path; then
	echo "warning: lattice_use_nix_devshell_path failed unexpectedly; continuing with inherited PATH" >&2
fi

run_and_report() {
	local step_name="${1:-}"
	if [[ -z "${step_name}" ]]; then
		echo "assertion failed: run_and_report requires a non-empty step name" >&2
		return 97
	fi
	shift

	if [[ "$#" -eq 0 ]]; then
		echo "assertion failed: run_and_report requires a command after the step name" >&2
		return 97
	fi

	local safe_name
	safe_name="$(printf '%s' "${step_name}" | tr -cs 'A-Za-z0-9._-' '_')"
	local workspace_tag="${LATTICE_WORKSPACE_ID:-local}"
	local log_file="/tmp/lattice-${workspace_tag}-${safe_name}.log"

	echo "==> Running ${step_name}"
	if "$@" >"${log_file}" 2>&1; then
		echo "==> ${step_name} passed"
		return 0
	else
		local exit_code=$?
		echo "==> ${step_name} failed (showing tail from ${log_file})" >&2
		tail -n 120 "${log_file}" >&2 || true
		return "${exit_code}"
	fi
}
