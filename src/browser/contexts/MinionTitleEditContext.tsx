import React, { createContext, useContext, useState, useCallback, useRef } from "react";
import type { Result } from "@/common/types/result";
import { getErrorMessage } from "@/common/utils/errors";

interface TitleEditResult {
  success: boolean;
  error?: string;
}

type RegenerateTitleResult = Result<{ title: string }, string>;

interface TitleEditContextValue {
  editingMinionId: string | null;
  requestEdit: (minionId: string, currentTitle: string) => boolean;
  confirmEdit: (minionId: string, newTitle: string) => Promise<TitleEditResult>;
  cancelEdit: () => void;
  /** Minion IDs whose titles are currently being generated by AI. */
  generatingTitleMinionIds: ReadonlySet<string>;
  /** Wraps an async title-generation call with loading state management. */
  wrapGenerateTitle: (minionId: string, fn: () => Promise<RegenerateTitleResult>) => void;
}

const TitleEditContext = createContext<TitleEditContextValue | null>(null);

interface TitleEditProviderProps {
  children: React.ReactNode;
  onUpdateTitle: (
    minionId: string,
    newTitle: string
  ) => Promise<{ success: boolean; error?: string }>;
}

export const TitleEditProvider: React.FC<TitleEditProviderProps> = ({
  children,
  onUpdateTitle,
}) => {
  const [editingMinionId, setEditingMinionId] = useState<string | null>(null);
  const [originalTitle, setOriginalTitle] = useState<string>("");

  const requestEdit = useCallback(
    (minionId: string, currentTitle: string): boolean => {
      // Only allow one minion to be edited at a time
      if (editingMinionId !== null && editingMinionId !== minionId) {
        return false;
      }

      setEditingMinionId(minionId);
      setOriginalTitle(currentTitle);
      return true;
    },
    [editingMinionId]
  );

  const confirmEdit = useCallback(
    async (minionId: string, newTitle: string): Promise<TitleEditResult> => {
      const trimmedTitle = newTitle.trim();

      // Short-circuit if title hasn't changed
      if (trimmedTitle === originalTitle) {
        setEditingMinionId(null);
        setOriginalTitle("");
        return { success: true };
      }

      if (!trimmedTitle) {
        return { success: false, error: "Title cannot be empty" };
      }

      const result = await onUpdateTitle(minionId, trimmedTitle);

      if (result.success) {
        setEditingMinionId(null);
        setOriginalTitle("");
      }

      return result;
    },
    [originalTitle, onUpdateTitle]
  );

  const cancelEdit = useCallback(() => {
    setEditingMinionId(null);
    setOriginalTitle("");
  }, []);

  // --- Generate title loading state ---
  const [generatingTitleMinionIds, setGeneratingTitleMinionIds] = useState<Set<string>>(
    () => new Set()
  );
  const regeneratingMinionIdsRef = useRef<Set<string>>(new Set());

  const wrapGenerateTitle = useCallback(
    (minionId: string, fn: () => Promise<RegenerateTitleResult>) => {
      // Ignore duplicate triggers while a regeneration is already in flight for this minion.
      if (regeneratingMinionIdsRef.current.has(minionId)) {
        return;
      }

      regeneratingMinionIdsRef.current.add(minionId);
      setGeneratingTitleMinionIds((current) => {
        if (current.has(minionId)) {
          return current;
        }
        const next = new Set(current);
        next.add(minionId);
        return next;
      });

      void Promise.resolve()
        .then(() => fn())
        .then((result) => {
          if (!result.success && typeof window !== "undefined") {
            window.alert(result.error);
          }
        })
        .catch((error: unknown) => {
          if (typeof window !== "undefined") {
            window.alert(getErrorMessage(error));
          }
        })
        .finally(() => {
          regeneratingMinionIdsRef.current.delete(minionId);
          setGeneratingTitleMinionIds((current) => {
            if (!current.has(minionId)) {
              return current;
            }
            const next = new Set(current);
            next.delete(minionId);
            return next;
          });
        });
    },
    []
  );

  const value: TitleEditContextValue = {
    editingMinionId,
    requestEdit,
    confirmEdit,
    cancelEdit,
    generatingTitleMinionIds,
    wrapGenerateTitle,
  };

  return <TitleEditContext.Provider value={value}>{children}</TitleEditContext.Provider>;
};

export const useTitleEdit = (): TitleEditContextValue => {
  const context = useContext(TitleEditContext);
  if (!context) {
    throw new Error("useTitleEdit must be used within a TitleEditProvider");
  }
  return context;
};
