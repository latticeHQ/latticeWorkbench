/**
 * Store for managing GitHub PR status information.
 *
 * Architecture:
 * - Lives outside React lifecycle (stable references)
 * - Detects minion PR from current branch via `gh pr view`
 * - Caches status with TTL
 * - Refreshes on focus (like GitStatusStore)
 * - Notifies subscribers when status changes
 *
 * PR detection:
 * - Branch-based: Runs `gh pr view` without URL to detect PR for current branch
 */

import type { RouterClient } from "@orpc/server";
import type { AppRouter } from "@/node/orpc/router";
import type { GitHubPRLink, GitHubPRStatus, GitHubPRLinkWithStatus } from "@/common/types/links";
import { createLRUCache } from "@/browser/utils/lruCache";
/**
 * Parse a GitHub PR URL to extract owner, repo, and number.
 * Returns null if the URL is not a valid GitHub PR URL.
 */
function parseGitHubPRUrl(url: string): { owner: string; repo: string; number: number } | null {
  const match = /^https?:\/\/github\.com\/([^/]+)\/([^/]+)\/pull\/(\d+)/.exec(url);
  if (!match) return null;
  return { owner: match[1], repo: match[2], number: parseInt(match[3], 10) };
}
import { MapStore } from "./MapStore";
import { RefreshController } from "@/browser/utils/RefreshController";
import { useSyncExternalStore } from "react";

// Cache TTL: PR status is refreshed at most every 5 seconds
const STATUS_CACHE_TTL_MS = 5 * 1000;

// How long to wait before retrying after an error
const ERROR_RETRY_DELAY_MS = 5 * 1000;

/**
 * Persisted PR status for localStorage LRU cache.
 * Stores only the essential data needed to display the badge on app restart.
 */
interface PersistedPRStatus {
  prLink: GitHubPRLink;
  status?: GitHubPRStatus;
}

// LRU cache for persisting PR status across app restarts
const prStatusLRU = createLRUCache<PersistedPRStatus>({
  entryPrefix: "prStatus:",
  indexKey: "prStatusIndex",
  maxEntries: 50,
  // No TTL - we refresh on mount anyway, just want instant display
});

function summarizeStatusCheckRollup(raw: unknown): {
  hasPendingChecks: boolean;
  hasFailedChecks: boolean;
} {
  if (!Array.isArray(raw)) {
    return { hasPendingChecks: false, hasFailedChecks: false };
  }

  let hasPendingChecks = false;
  let hasFailedChecks = false;

  for (const item of raw) {
    if (typeof item !== "object" || item === null) {
      continue;
    }

    const record = item as Record<string, unknown>;
    const status = record.status;
    const conclusion = record.conclusion;

    // Many check APIs represent "pending" as a non-COMPLETED status and/or a null conclusion.
    if (typeof status === "string" && status !== "COMPLETED") {
      hasPendingChecks = true;
    }

    if (conclusion == null) {
      hasPendingChecks = true;
      continue;
    }

    if (typeof conclusion === "string") {
      // GitHub-style conclusions (StatusState is different from CheckConclusionState, but this is close enough)
      const normalized = conclusion.toUpperCase();
      if (
        normalized === "FAILURE" ||
        normalized === "CANCELLED" ||
        normalized === "TIMED_OUT" ||
        normalized === "ACTION_REQUIRED" ||
        normalized === "STARTUP_FAILURE"
      ) {
        hasFailedChecks = true;
      }
    }
  }

  return { hasPendingChecks, hasFailedChecks };
}

/**
 * Minion PR detection result (from branch, not chat).
 */
interface MinionPRCacheEntry {
  /** The detected PR link (null if no PR for this branch) */
  prLink: GitHubPRLink | null;
  /** PR status if available */
  status?: GitHubPRStatus;
  error?: string;
  fetchedAt: number;
  loading: boolean;
}

/**
 * Store for GitHub PR status. Fetches status via gh CLI and caches results.
 */
export class PRStatusStore {
  private client: RouterClient<AppRouter> | null = null;
  private readonly refreshController: RefreshController;
  private isActive = true;

  // Minion-based PR detection (keyed by minionId)
  private minionPRSubscriptions = new MapStore<string, MinionPRCacheEntry>();
  private minionPRCache = new Map<string, MinionPRCacheEntry>();

  // Track active subscriptions per minion so we only refresh minions that are actually visible.
  private minionSubscriptionCounts = new Map<string, number>();

  // Like GitStatusStore: batch immediate refreshes triggered by subscriptions.
  private immediateUpdateQueued = false;

  constructor() {
    this.refreshController = new RefreshController({
      onRefresh: () => this.refreshAll(),
      debounceMs: 5000,
      refreshOnFocus: true,
      focusDebounceMs: 1000,
    });
  }

  setClient(client: RouterClient<AppRouter> | null): void {
    this.client = client;

    if (!client) {
      return;
    }

    // If hooks subscribed before the client was ready, ensure we refresh once it is.
    if (this.minionSubscriptionCounts.size > 0) {
      this.refreshController.requestImmediate();
    }
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Minion-based PR detection (primary mode)
  // ─────────────────────────────────────────────────────────────────────────────

  /**
   * Subscribe to minion PR changes (branch-based detection).
   *
   * Like GitStatusStore: subscriptions drive refresh. Components should not need to
   * manually "monitor" minions.
   */
  subscribeMinion = (minionId: string, listener: () => void) => {
    const unsubscribe = this.minionPRSubscriptions.subscribeKey(minionId, listener);

    // Track active subscriptions so focus refresh only runs for visible minions.
    const current = this.minionSubscriptionCounts.get(minionId) ?? 0;
    this.minionSubscriptionCounts.set(minionId, current + 1);

    // Bind focus/visibility listeners once we have any subscribers.
    this.refreshController.bindListeners();

    // Kick an immediate refresh so the UI doesn't wait for the next focus event.
    // Use a microtask to batch multiple subscribe calls in the same render.
    if (!this.immediateUpdateQueued && this.isActive && this.client) {
      this.immediateUpdateQueued = true;
      queueMicrotask(() => {
        this.immediateUpdateQueued = false;
        this.refreshController.requestImmediate();
      });
    }

    return () => {
      unsubscribe();
      const next = (this.minionSubscriptionCounts.get(minionId) ?? 1) - 1;
      if (next <= 0) {
        this.minionSubscriptionCounts.delete(minionId);
      } else {
        this.minionSubscriptionCounts.set(minionId, next);
      }
    };
  };

  /**
   * Get minion PR detection result.
   * Checks in-memory cache first, then falls back to localStorage for persistence
   * across app restarts.
   */
  getMinionPR(minionId: string): MinionPRCacheEntry | undefined {
    const memCached = this.minionPRCache.get(minionId);
    if (memCached) return memCached;

    // Check localStorage for persisted status (app restart scenario)
    const persisted = prStatusLRU.get(minionId);
    if (persisted) {
      // Hydrate memory cache from localStorage, mark as loading to trigger refresh
      // but show the cached value immediately (optimistic UI)
      const entry: MinionPRCacheEntry = {
        prLink: persisted.prLink,
        status: persisted.status,
        loading: true,
        fetchedAt: 0,
      };
      this.minionPRCache.set(minionId, entry);
      return entry;
    }

    return undefined;
  }

  /**
   * Detect PR for minion's current branch via `gh pr view`.
   */
  private async detectMinionPR(minionId: string): Promise<void> {
    if (!this.client || !this.isActive) return;

    // Mark as loading
    const existing = this.minionPRCache.get(minionId);
    this.minionPRCache.set(minionId, {
      prLink: existing?.prLink ?? null,
      status: existing?.status,
      loading: true,
      fetchedAt: Date.now(),
    });
    this.minionPRSubscriptions.bump(minionId);

    try {
      // Run gh pr view without URL - detects PR for current branch
      const result = await this.client.minion.executeBash({
        minionId,
        script: `gh pr view --json number,url,state,mergeable,mergeStateStatus,title,isDraft,headRefName,baseRefName,statusCheckRollup 2>/dev/null || echo '{"no_pr":true}'`,
        options: { timeout_secs: 15 },
      });

      if (!this.isActive) return;

      if (!result.success || !result.data.success) {
        this.minionPRCache.set(minionId, {
          prLink: null,
          error: "Failed to run gh CLI",
          loading: false,
          fetchedAt: Date.now(),
        });
        this.minionPRSubscriptions.bump(minionId);
        return;
      }

      const output = result.data.output;
      if (output) {
        const parsed = JSON.parse(output) as Record<string, unknown>;

        if ("no_pr" in parsed) {
          // No PR for this branch
          this.minionPRCache.set(minionId, {
            prLink: null,
            loading: false,
            fetchedAt: Date.now(),
          });
        } else {
          // Parse PR link from URL
          const prUrl = parsed.url as string;
          const prLinkBase = parseGitHubPRUrl(prUrl);

          if (!prLinkBase) {
            this.minionPRCache.set(minionId, {
              prLink: null,
              error: "Invalid PR URL from gh CLI",
              loading: false,
              fetchedAt: Date.now(),
            });
          } else {
            const { hasPendingChecks, hasFailedChecks } = summarizeStatusCheckRollup(
              parsed.statusCheckRollup
            );

            const status: GitHubPRStatus = {
              state: (parsed.state as GitHubPRStatus["state"]) ?? "OPEN",
              mergeable: (parsed.mergeable as GitHubPRStatus["mergeable"]) ?? "UNKNOWN",
              mergeStateStatus:
                (parsed.mergeStateStatus as GitHubPRStatus["mergeStateStatus"]) ?? "UNKNOWN",
              title: (parsed.title as string) ?? "",
              isDraft: (parsed.isDraft as boolean) ?? false,
              headRefName: (parsed.headRefName as string) ?? "",
              baseRefName: (parsed.baseRefName as string) ?? "",
              hasPendingChecks,
              hasFailedChecks,
              fetchedAt: Date.now(),
            };

            const prLink: GitHubPRLink = {
              type: "github-pr",
              url: prUrl,
              ...prLinkBase,
              detectedAt: Date.now(),
              occurrenceCount: 1,
            };

            this.minionPRCache.set(minionId, {
              prLink,
              status,
              loading: false,
              fetchedAt: Date.now(),
            });

            // Persist to localStorage for instant display on app restart
            prStatusLRU.set(minionId, { prLink, status });
          }
        }
      } else {
        this.minionPRCache.set(minionId, {
          prLink: null,
          error: "Empty response from gh CLI",
          loading: false,
          fetchedAt: Date.now(),
        });
      }

      this.minionPRSubscriptions.bump(minionId);
    } catch (err) {
      if (!this.isActive) return;

      this.minionPRCache.set(minionId, {
        prLink: null,
        error: err instanceof Error ? err.message : "Unknown error",
        loading: false,
        fetchedAt: Date.now(),
      });
      this.minionPRSubscriptions.bump(minionId);
    }
  }

  private shouldFetchMinion(entry: MinionPRCacheEntry | undefined, now: number): boolean {
    if (!entry) return true;
    // Allow refresh if entry was hydrated from localStorage (fetchedAt === 0)
    // but is marked loading - this means we have stale cached data and need fresh data.
    if (entry.loading && entry.fetchedAt !== 0) return false;

    if (entry.error) {
      return now - entry.fetchedAt > ERROR_RETRY_DELAY_MS;
    }

    return now - entry.fetchedAt > STATUS_CACHE_TTL_MS;
  }

  /**
   * Refresh PR status for all subscribed minions.
   * Called via RefreshController (focus + debounced refresh).
   */
  private async refreshAll(): Promise<void> {
    if (!this.client || !this.isActive) return;

    const minionIds = Array.from(this.minionSubscriptionCounts.keys());
    if (minionIds.length === 0) {
      return;
    }

    const now = Date.now();
    const refreshes: Array<Promise<void>> = [];

    for (const minionId of minionIds) {
      const cached = this.minionPRCache.get(minionId);
      if (this.shouldFetchMinion(cached, now)) {
        refreshes.push(this.detectMinionPR(minionId));
      }
    }

    await Promise.all(refreshes);
  }

  /**
   * Dispose the store.
   */
  dispose(): void {
    this.isActive = false;
    this.refreshController.dispose();
  }
}

// Singleton instance
let storeInstance: PRStatusStore | null = null;

export function getPRStatusStoreInstance(): PRStatusStore {
  storeInstance ??= new PRStatusStore();
  return storeInstance;
}

export function setPRStatusStoreInstance(store: PRStatusStore): void {
  storeInstance = store;
}

// ─────────────────────────────────────────────────────────────────────────────
// React hooks
// ─────────────────────────────────────────────────────────────────────────────

// Cache for useMinionPR hook to return stable references
const minionPRHookCache = new Map<string, GitHubPRLinkWithStatus | null>();

/**
 * Hook to get PR for a minion (branch-based detection).
 * Returns the detected PR with status, or null if no PR for this branch.
 */
export function useMinionPR(minionId: string): GitHubPRLinkWithStatus | null {
  const store = getPRStatusStoreInstance();

  return useSyncExternalStore(
    (listener) => store.subscribeMinion(minionId, listener),
    () => {
      const cached = store.getMinionPR(minionId);
      const existing = minionPRHookCache.get(minionId);

      // No data yet
      if (!cached) {
        if (existing === null) return existing;
        minionPRHookCache.set(minionId, null);
        return null;
      }

      // No PR for this branch
      if (!cached.prLink) {
        if (existing === null) return existing;
        minionPRHookCache.set(minionId, null);
        return null;
      }

      // Return same reference if nothing meaningful changed
      if (
        existing?.url === cached.prLink.url &&
        existing.status === cached.status &&
        existing.loading === cached.loading &&
        existing.error === cached.error
      ) {
        return existing;
      }

      // Build new object and cache it
      const newResult: GitHubPRLinkWithStatus = {
        ...cached.prLink,
        status: cached.status,
        loading: cached.loading,
        error: cached.error,
      };
      minionPRHookCache.set(minionId, newResult);
      return newResult;
    }
  );
}
